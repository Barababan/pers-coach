<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pers.coach | Shadow Training</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', sans-serif;
            /* Studio background image */
            background: url('studio_gray_dark.jpg') center center / cover no-repeat;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Main stage - full screen */
        .stage {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: 20px;
            padding-bottom: 80px;
            gap: 15px;
        }
        
        /* Panels */
        .panel {
            position: relative;
            height: 100%;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }
        
        .trainer-panel { flex: 0 0 auto; }
        .avatar-panel { flex: 0 0 280px; }
        .user-panel { flex: 0 0 auto; }
        
        /* Video containers */
        .trainer-wrap, .user-wrap {
            position: relative;
            height: 100%;
        }
        
        #trainerVideo {
            height: 100%;
            width: auto;
            border-radius: 12px;
        }
        
        #trainerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #avatarCanvas {
            width: 280px;
            height: 100%;
            border-radius: 12px;
        }
        
        .user-wrap {
            width: 220px;
            overflow: hidden;
            border-radius: 12px;
        }
        
        #userVideo {
            height: 100%;
            width: 220px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #userCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Compact controls overlay */
        .controls {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 24px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        
        .play-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffd5, #00d4ff);
            color: #000;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .timeline {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
            border-radius: 2px;
            width: 0%;
        }
        
        .stat {
            text-align: center;
            min-width: 60px;
        }
        
        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 700;
            color: #00ffd5;
        }
        
        .stat-label {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
        }
        
        .time-display {
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        /* Logo */
        .logo {
            position: fixed;
            top: 16px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 900;
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 100;
        }
        
        /* Settings gear */
        .settings-btn {
            position: fixed;
            top: 16px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(20, 20, 30, 0.8);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            z-index: 100;
        }
        
        /* Settings panel */
        .settings-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 16px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            display: none;
        }
        
        .settings-panel.show { display: block; }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            gap: 20px;
        }
        
        .toggle-label { font-size: 12px; color: rgba(255,255,255,0.7); }
        
        .toggle {
            position: relative;
            width: 40px;
            height: 22px;
            cursor: pointer;
        }
        
        .toggle input { opacity: 0; width: 0; height: 0; }
        
        .toggle-slider {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 11px;
            transition: 0.3s;
        }
        
        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            left: 3px;
            top: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
        }
        
        .toggle input:checked + .toggle-slider::before {
            transform: translateX(18px);
        }
        
        /* Feedback */
        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Orbitron', monospace;
            font-size: 36px;
            font-weight: 900;
            padding: 16px 32px;
            border-radius: 16px;
            background: rgba(0,0,0,0.8);
            border: 2px solid;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .feedback.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .feedback.great { color: #00ff88; border-color: #00ff88; }
        .feedback.good { color: #ffd93d; border-color: #ffd93d; }
        .feedback.try { color: #ff6b6b; border-color: #ff6b6b; }
        
        /* Start overlay */
        .start-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 200;
        }
        
        .start-overlay.hidden { display: none; }
        
        .start-btn {
            padding: 16px 48px;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            border: none;
            border-radius: 24px;
            background: linear-gradient(135deg, #00ffd5, #00d4ff);
            color: #000;
            cursor: pointer;
        }
        
        .start-text { color: rgba(255,255,255,0.4); font-size: 13px; }
    </style>
</head>
<body>
    <div class="logo">pers.coach</div>
    
    <button class="settings-btn" onclick="toggleSettings()">⚙️</button>
    
    <div class="settings-panel" id="settingsPanel">
        <div class="toggle-row">
            <span class="toggle-label">Тень юзера</span>
            <label class="toggle">
                <input type="checkbox" id="toggleShadow" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span class="toggle-label">Линии тренера</span>
            <label class="toggle">
                <input type="checkbox" id="toggleTrainerSkel" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span class="toggle-label">Линии юзера</span>
            <label class="toggle">
                <input type="checkbox" id="toggleUserSkel" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span class="toggle-label">3D манекен</span>
            <label class="toggle">
                <input type="checkbox" id="toggleAvatar" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
    </div>
    
    <div class="stage">
        <div class="panel trainer-panel">
            <div class="trainer-wrap">
                <video id="trainerVideo" playsinline muted loop>
                    <source src="output/trainer_transparent.webm" type="video/webm">
                </video>
                <canvas id="trainerCanvas"></canvas>
            </div>
        </div>
        
        <div class="panel avatar-panel">
            <canvas id="avatarCanvas"></canvas>
        </div>
        
        <div class="panel user-panel">
            <div class="user-wrap">
                <video id="userVideo" playsinline autoplay></video>
                <canvas id="userCanvas"></canvas>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button class="play-btn" id="playBtn">▶</button>
        <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
        </div>
        <div class="time-display" id="timeDisplay">0:00</div>
        <div class="stat">
            <div class="stat-value" id="scoreValue">0%</div>
            <div class="stat-label">Точность</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="repsValue">0</div>
            <div class="stat-label">Повторы</div>
        </div>
    </div>
    
    <div class="feedback" id="feedback"></div>
    
    <div class="start-overlay" id="startOverlay">
        <div class="logo" style="font-size:42px;">pers.coach</div>
        <p class="start-text">Нажмите для начала тренировки</p>
        <button class="start-btn" id="startBtn">Начать</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

    <script>
        // Elements
        const trainerVideo = document.getElementById('trainerVideo');
        const trainerCanvas = document.getElementById('trainerCanvas');
        const trainerCtx = trainerCanvas.getContext('2d');
        const userVideo = document.getElementById('userVideo');
        const userCanvas = document.getElementById('userCanvas');
        const userCtx = userCanvas.getContext('2d');
        const avatarCanvas = document.getElementById('avatarCanvas');
        
        // State
        let trainerPoses = null;
        let userLandmarks = null;
        let showShadow = true, showTrainerSkel = true, showUserSkel = true, showAvatar = true;
        let similarity = 0, reps = 0, wasLow = false;
        let limbScores = { leftArm: 0, rightArm: 0, leftLeg: 0, rightLeg: 0, torso: 0 };
        
        // MHR70 / MediaPipe limb mappings
        const MHR_LIMBS = {
            leftUpperArm: [5, 7], leftForearm: [7, 62],
            rightUpperArm: [6, 8], rightForearm: [8, 41],
            leftThigh: [9, 11], leftShin: [11, 13],
            rightThigh: [10, 12], rightShin: [12, 14],
            torsoLeft: [5, 9], torsoRight: [6, 10],
            shoulders: [5, 6], hips: [9, 10]
        };
        
        const MP_LIMBS = {
            leftUpperArm: [11, 13], leftForearm: [13, 15],
            rightUpperArm: [12, 14], rightForearm: [14, 16],
            leftThigh: [23, 25], leftShin: [25, 27],
            rightThigh: [24, 26], rightShin: [26, 28],
            torsoLeft: [11, 23], torsoRight: [12, 24],
            shoulders: [11, 12], hips: [23, 24]
        };
        
        // Load poses
        fetch('output/poses/trainer_poses.json')
            .then(r => r.json())
            .then(data => {
                trainerPoses = data;
                console.log('Poses loaded:', data.poses.length);
                init3DAvatar();
            });
        
        // Toggles
        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('show');
        }
        document.getElementById('toggleShadow').onchange = e => showShadow = e.target.checked;
        document.getElementById('toggleTrainerSkel').onchange = e => showTrainerSkel = e.target.checked;
        document.getElementById('toggleUserSkel').onchange = e => showUserSkel = e.target.checked;
        document.getElementById('toggleAvatar').onchange = e => {
            showAvatar = e.target.checked;
            avatarCanvas.style.opacity = showAvatar ? 1 : 0.2;
        };
        
        // ============ THREE.JS MANNEQUIN ============
        let scene, camera, renderer, mannequin;
        let avatarRotation = 0;
        
        function init3DAvatar() {
            const w = 280, h = avatarCanvas.parentElement.clientHeight || 600;
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(40, w / h, 0.1, 100);
            camera.position.set(0, 0.7, 2.5);
            camera.lookAt(0, 0.7, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: avatarCanvas, alpha: true, antialias: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const key = new THREE.DirectionalLight(0xffffff, 0.8);
            key.position.set(2, 3, 2);
            scene.add(key);
            const fill = new THREE.DirectionalLight(0xffffff, 0.3);
            fill.position.set(-2, 2, 1);
            scene.add(fill);
            
            mannequin = new THREE.Group();
            scene.add(mannequin);
            
            console.log('3D Mannequin init, h=', h);
        }
        
        function update3DAvatar(pose) {
            if (!mannequin || !pose) return;
            
            // Clear
            while(mannequin.children.length) {
                const c = mannequin.children[0];
                if (c.geometry) c.geometry.dispose();
                if (c.material) c.material.dispose();
                mannequin.remove(c);
            }
            
            const joints = pose.joints_3d;
            if (!joints || joints.length < 15) return;
            
            // SAM 3D Body coords: X=left/right, Y=down (negative up), Z=depth
            // Find bounds for normalization
            const idx = [5, 6, 9, 10, 11, 12, 13, 14];
            let minY = Infinity, maxY = -Infinity, sumX = 0, sumZ = 0;
            
            for (const i of idx) {
                if (i < joints.length) {
                    const j = joints[i];
                    sumX += j[0];
                    sumZ += j[2];
                    minY = Math.min(minY, j[1]);
                    maxY = Math.max(maxY, j[1]);
                }
            }
            
            const cx = sumX / idx.length;
            const cz = sumZ / idx.length;
            const bodyHeight = Math.abs(maxY - minY) || 1;
            const scale = 1.3 / bodyHeight;
            
            // Convert SAM coords to Three.js
            // SAM: Y is negative, more negative = lower (shoulder -0.2, ankle -0.9)
            // Three.js: Y up (positive)
            // So: (j[1] - minY) converts -0.9..-0.2 to 0..0.7
            // Mirror X so left/right matches video perspective
            function toPos(i) {
                if (i >= joints.length) return null;
                const j = joints[i];
                return new THREE.Vector3(
                    -(j[0] - cx) * scale,  // Mirror X for correct left/right
                    (j[1] - minY) * scale, // minY (ankle=-0.9) becomes 0, maxY (shoulder=-0.2) becomes high
                    -(j[2] - cz) * scale   // Flip Z so facing camera
                );
            }
            
            // Materials
            const wood = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.5 });
            const darkWood = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.4 });
            const jointMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.7 });
            
            function addLimb(p1, p2, r, mat) {
                if (!p1 || !p2) return;
                const d = new THREE.Vector3().subVectors(p2, p1);
                const len = d.length();
                if (len < 0.01) return;
                const geom = new THREE.CylinderGeometry(r * 0.85, r, len, 10);
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.lerpVectors(p1, p2, 0.5);
                mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), d.normalize());
                mannequin.add(mesh);
            }
            
            function addJoint(p, r) {
                if (!p) return;
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 10, 10), jointMat);
                mesh.position.copy(p);
                mannequin.add(mesh);
            }
            
            // Get all positions
            const lShoulder = toPos(5), rShoulder = toPos(6);
            const lElbow = toPos(7), rElbow = toPos(8);
            const lWrist = toPos(62), rWrist = toPos(41);
            const lHip = toPos(9), rHip = toPos(10);
            const lKnee = toPos(11), rKnee = toPos(12);
            const lAnkle = toPos(13), rAnkle = toPos(14);
            
            // Derived positions
            let neck = null, head = null, pelvisCenter = null;
            if (lShoulder && rShoulder) {
                neck = new THREE.Vector3().lerpVectors(lShoulder, rShoulder, 0.5);
                head = neck.clone().add(new THREE.Vector3(0, 0.15, 0));
            }
            if (lHip && rHip) {
                pelvisCenter = new THREE.Vector3().lerpVectors(lHip, rHip, 0.5);
            }
            
            // Head
            if (head) {
                const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 14, 14), wood);
                headMesh.scale.set(0.85, 1.05, 0.9);
                headMesh.position.copy(head);
                mannequin.add(headMesh);
            }
            
            // Neck
            if (neck && head) addLimb(neck, head.clone().sub(new THREE.Vector3(0, 0.07, 0)), 0.025, wood);
            
            // Torso
            if (neck && pelvisCenter) {
                const torsoH = neck.y - pelvisCenter.y;
                const torsoGeom = new THREE.CylinderGeometry(0.08, 0.11, torsoH * 0.95, 12);
                const torso = new THREE.Mesh(torsoGeom, wood);
                torso.position.lerpVectors(neck, pelvisCenter, 0.5);
                mannequin.add(torso);
            }
            
            // Pelvis
            if (pelvisCenter) {
                const pelvis = new THREE.Mesh(new THREE.SphereGeometry(0.09, 12, 12), wood);
                pelvis.scale.set(1.1, 0.6, 0.7);
                pelvis.position.copy(pelvisCenter);
                mannequin.add(pelvis);
            }
            
            // Joints
            addJoint(lShoulder, 0.035);
            addJoint(rShoulder, 0.035);
            addJoint(lElbow, 0.028);
            addJoint(rElbow, 0.028);
            addJoint(lHip, 0.038);
            addJoint(rHip, 0.038);
            addJoint(lKnee, 0.032);
            addJoint(rKnee, 0.032);
            
            // Arms
            addLimb(lShoulder, lElbow, 0.028, wood);
            addLimb(rShoulder, rElbow, 0.028, wood);
            addLimb(lElbow, lWrist, 0.022, wood);
            addLimb(rElbow, rWrist, 0.022, wood);
            
            // Hands
            if (lWrist) {
                const h = new THREE.Mesh(new THREE.SphereGeometry(0.022, 8, 8), wood);
                h.scale.set(0.7, 1.1, 0.5);
                h.position.copy(lWrist);
                mannequin.add(h);
            }
            if (rWrist) {
                const h = new THREE.Mesh(new THREE.SphereGeometry(0.022, 8, 8), wood);
                h.scale.set(0.7, 1.1, 0.5);
                h.position.copy(rWrist);
                mannequin.add(h);
            }
            
            // Legs
            addLimb(lHip, lKnee, 0.038, wood);
            addLimb(rHip, rKnee, 0.038, wood);
            addLimb(lKnee, lAnkle, 0.03, wood);
            addLimb(rKnee, rAnkle, 0.03, wood);
            
            // Feet
            if (lAnkle) {
                const f = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.02, 0.1), darkWood);
                f.position.copy(lAnkle).add(new THREE.Vector3(0, -0.01, 0.03));
                mannequin.add(f);
            }
            if (rAnkle) {
                const f = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.02, 0.1), darkWood);
                f.position.copy(rAnkle).add(new THREE.Vector3(0, -0.01, 0.03));
                mannequin.add(f);
            }
            
            avatarRotation += 0.007;
            mannequin.rotation.y = avatarRotation;
        }
        
        function render3D() {
            if (renderer && scene && camera) renderer.render(scene, camera);
        }
        
        // ============ START ============
        document.getElementById('startBtn').onclick = async () => {
            document.getElementById('startOverlay').classList.add('hidden');
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'user' }
            });
            userVideo.srcObject = stream;
            
            const pose = new Pose({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(r => { userLandmarks = r.poseLandmarks; });
            
            const cam = new Camera(userVideo, {
                onFrame: async () => { await pose.send({ image: userVideo }); },
                width: 640, height: 480
            });
            cam.start();
            
            // Skip first ~1 second where trainer walks into position
            trainerVideo.currentTime = 1.0;
            trainerVideo.play();
            document.getElementById('playBtn').textContent = '⏸';
            
            requestAnimationFrame(loop);
        };
        
        document.getElementById('playBtn').onclick = () => {
            if (trainerVideo.paused) {
                trainerVideo.play();
                document.getElementById('playBtn').textContent = '⏸';
            } else {
                trainerVideo.pause();
                document.getElementById('playBtn').textContent = '▶';
            }
        };
        
        document.getElementById('timeline').onclick = e => {
            const r = e.target.getBoundingClientRect();
            trainerVideo.currentTime = ((e.clientX - r.left) / r.width) * trainerVideo.duration;
        };
        
        // ============ MAIN LOOP ============
        function loop() {
            const pose = getPose();
            drawTrainer(pose);
            drawUser(pose);
            calcSimilarity(pose);
            if (showAvatar) update3DAvatar(pose);
            render3D();
            updateUI();
            requestAnimationFrame(loop);
        }
        
        function getPose() {
            if (!trainerPoses) return null;
            const t = trainerVideo.currentTime;
            const fi = Math.floor(t * trainerPoses.original_fps);
            let pi = Math.floor(fi / trainerPoses.skip_frames);
            pi = Math.max(0, Math.min(pi, trainerPoses.poses.length - 1));
            return trainerPoses.poses[pi];
        }
        
        function getColor(score) {
            if (score >= 0.7) return '#00ff88';
            if (score >= 0.4) return '#ffd93d';
            return '#ff6b6b';
        }
        
        function drawTrainer(pose) {
            const rect = trainerVideo.getBoundingClientRect();
            trainerCanvas.width = rect.width;
            trainerCanvas.height = rect.height;
            trainerCtx.clearRect(0, 0, rect.width, rect.height);
            
            if (!showTrainerSkel || !pose) return;
            
            const kp = pose.keypoints_2d;
            const sx = rect.width / trainerPoses.width;
            const sy = rect.height / trainerPoses.height;
            
            trainerCtx.lineWidth = 6;
            trainerCtx.lineCap = 'round';
            
            const groups = {
                leftArm: ['leftUpperArm', 'leftForearm'],
                rightArm: ['rightUpperArm', 'rightForearm'],
                leftLeg: ['leftThigh', 'leftShin'],
                rightLeg: ['rightThigh', 'rightShin'],
                torso: ['torsoLeft', 'torsoRight', 'shoulders', 'hips']
            };
            
            for (const [g, limbs] of Object.entries(groups)) {
                const color = getColor(limbScores[g] || 0);
                trainerCtx.strokeStyle = color;
                trainerCtx.shadowColor = color;
                trainerCtx.shadowBlur = 8;
                
                for (const name of limbs) {
                    const [i, j] = MHR_LIMBS[name];
                    if (i >= kp.length || j >= kp.length) continue;
                    trainerCtx.beginPath();
                    trainerCtx.moveTo(kp[i][0] * sx, kp[i][1] * sy);
                    trainerCtx.lineTo(kp[j][0] * sx, kp[j][1] * sy);
                    trainerCtx.stroke();
                }
            }
        }
        
        function drawUser(pose) {
            const rect = userVideo.getBoundingClientRect();
            userCanvas.width = rect.width;
            userCanvas.height = rect.height;
            userCtx.clearRect(0, 0, rect.width, rect.height);
            
            userVideo.style.opacity = showShadow ? 0.8 : 0;
            if (!showUserSkel || !userLandmarks) return;
            
            userCtx.lineWidth = 6;
            userCtx.lineCap = 'round';
            
            const groups = {
                leftArm: ['leftUpperArm', 'leftForearm'],
                rightArm: ['rightUpperArm', 'rightForearm'],
                leftLeg: ['leftThigh', 'leftShin'],
                rightLeg: ['rightThigh', 'rightShin'],
                torso: ['torsoLeft', 'torsoRight', 'shoulders', 'hips']
            };
            
            for (const [g, limbs] of Object.entries(groups)) {
                const color = getColor(limbScores[g] || 0);
                userCtx.strokeStyle = color;
                userCtx.shadowColor = color;
                userCtx.shadowBlur = 8;
                
                for (const name of limbs) {
                    const [i, j] = MP_LIMBS[name];
                    const p1 = userLandmarks[i], p2 = userLandmarks[j];
                    if (!p1 || !p2 || p1.visibility < 0.5 || p2.visibility < 0.5) continue;
                    userCtx.beginPath();
                    userCtx.moveTo((1 - p1.x) * rect.width, p1.y * rect.height);
                    userCtx.lineTo((1 - p2.x) * rect.width, p2.y * rect.height);
                    userCtx.stroke();
                }
            }
        }
        
        function calcSimilarity(pose) {
            if (!userLandmarks || !pose) return;
            const tkp = pose.keypoints_2d;
            
            function angle(limbs, isUser) {
                const angles = [];
                for (const name of limbs) {
                    const [i, j] = isUser ? MP_LIMBS[name] : MHR_LIMBS[name];
                    let x1, y1, x2, y2;
                    if (isUser) {
                        const p1 = userLandmarks[i], p2 = userLandmarks[j];
                        if (!p1 || !p2 || p1.visibility < 0.5 || p2.visibility < 0.5) continue;
                        x1 = p1.x; y1 = p1.y; x2 = p2.x; y2 = p2.y;
                    } else {
                        if (i >= tkp.length || j >= tkp.length) continue;
                        x1 = tkp[i][0] / trainerPoses.width;
                        y1 = tkp[i][1] / trainerPoses.height;
                        x2 = tkp[j][0] / trainerPoses.width;
                        y2 = tkp[j][1] / trainerPoses.height;
                    }
                    angles.push(Math.atan2(y2 - y1, x2 - x1));
                }
                return angles;
            }
            
            const groups = {
                leftArm: ['leftUpperArm', 'leftForearm'],
                rightArm: ['rightUpperArm', 'rightForearm'],
                leftLeg: ['leftThigh', 'leftShin'],
                rightLeg: ['rightThigh', 'rightShin'],
                torso: ['torsoLeft', 'torsoRight']
            };
            
            let total = 0, cnt = 0;
            for (const [g, limbs] of Object.entries(groups)) {
                const ua = angle(limbs, true), ta = angle(limbs, false);
                if (!ua.length || !ta.length) { limbScores[g] = 0; continue; }
                
                let diff = 0;
                const n = Math.min(ua.length, ta.length);
                for (let i = 0; i < n; i++) {
                    let d = Math.abs(-ua[i] - ta[i]);
                    if (d > Math.PI) d = 2 * Math.PI - d;
                    diff += d;
                }
                diff /= n;
                const score = Math.max(0, 1 - diff / (Math.PI / 2));
                limbScores[g] = score;
                total += score;
                cnt++;
            }
            
            similarity = cnt ? (total / cnt) * 100 : 0;
            
            // Rep counting
            const hip = userLandmarks[23];
            if (hip && hip.visibility > 0.5) {
                const isLow = hip.y > 0.6;
                if (isLow && !wasLow) { reps++; showFeedback(similarity); }
                wasLow = isLow;
            }
        }
        
        function showFeedback(score) {
            const el = document.getElementById('feedback');
            el.textContent = score >= 70 ? 'ОТЛИЧНО!' : score >= 40 ? 'ХОРОШО' : 'СТАРАЙСЯ!';
            el.className = 'feedback show ' + (score >= 70 ? 'great' : score >= 40 ? 'good' : 'try');
            setTimeout(() => el.classList.remove('show'), 1500);
        }
        
        function updateUI() {
            document.getElementById('scoreValue').textContent = Math.round(similarity) + '%';
            document.getElementById('repsValue').textContent = reps;
            if (trainerVideo.duration) {
                const pct = (trainerVideo.currentTime / trainerVideo.duration) * 100;
                document.getElementById('timelineProgress').style.width = pct + '%';
                const m = Math.floor(trainerVideo.currentTime / 60);
                const s = Math.floor(trainerVideo.currentTime % 60);
                document.getElementById('timeDisplay').textContent = `${m}:${s.toString().padStart(2,'0')}`;
            }
        }
    </script>
</body>
</html>
