<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pers.coach | Smart Mirror</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Full-screen mirror container */
        .mirror {
            position: absolute;
            inset: 0;
        }
        
        /* User webcam - full screen, very transparent (like reflection) */
        #userVideo {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.25;
            z-index: 1;
        }
        
        /* Silhouette canvas - full screen, mirrored like webcam */
        #silhouetteCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        /* Trainer video - centered, with skeleton */
        .trainer-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 85vh;
            z-index: 10;
        }
        
        #trainerVideo {
            height: 100%;
            width: auto;
            border-radius: 8px;
        }
        
        #trainerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Logo */
        .logo {
            position: fixed;
            top: 20px;
            left: 24px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 900;
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            z-index: 100;
        }
        
        /* Settings gear */
        .settings-btn {
            position: fixed;
            top: 16px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255,255,255,0.7);
            font-size: 18px;
            cursor: pointer;
            z-index: 100;
            transition: background 0.2s;
        }
        
        .settings-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        
        /* Settings panel */
        .settings-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            display: none;
        }
        
        .settings-panel.show { display: block; }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            gap: 20px;
        }
        
        .toggle-label { font-size: 12px; color: rgba(255,255,255,0.7); }
        
        .toggle {
            position: relative;
            width: 40px;
            height: 22px;
            cursor: pointer;
        }
        
        .toggle input { opacity: 0; width: 0; height: 0; }
        
        .toggle-slider {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 11px;
            transition: 0.3s;
        }
        
        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            left: 3px;
            top: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
        }
        
        .toggle input:checked + .toggle-slider::before {
            transform: translateX(18px);
        }
        
        .slider-row {
            padding: 8px 0;
        }
        
        .slider-row input[type="range"] {
            width: 100%;
            margin-top: 8px;
        }
        
        /* Compact controls */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        
        .play-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffd5, #00d4ff);
            color: #000;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .timeline {
            width: 180px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ffd5, #00d4ff);
            border-radius: 2px;
            width: 0%;
        }
        
        .stat {
            text-align: center;
            min-width: 50px;
        }
        
        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #00ffd5;
        }
        
        .stat-label {
            font-size: 8px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
        }
        
        .time-display {
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        /* Feedback popup */
        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Orbitron', monospace;
            font-size: 36px;
            font-weight: 900;
            padding: 16px 32px;
            border-radius: 16px;
            background: rgba(0,0,0,0.8);
            border: 2px solid;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .feedback.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .feedback.great { color: #00ff88; border-color: #00ff88; }
        .feedback.good { color: #ffd93d; border-color: #ffd93d; }
        .feedback.try { color: #ff6b6b; border-color: #ff6b6b; }
        
        /* Start overlay */
        .start-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 200;
        }
        
        .start-overlay.hidden { display: none; }
        
        .start-btn {
            padding: 16px 48px;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            border: none;
            border-radius: 24px;
            background: linear-gradient(135deg, #00ffd5, #00d4ff);
            color: #000;
            cursor: pointer;
        }
        
        .start-text { color: rgba(255,255,255,0.4); font-size: 13px; }
    </style>
</head>
<body>
    <div class="logo">pers.coach</div>
    
    <button class="settings-btn" onclick="toggleSettings()">⚙️</button>
    
    <div class="settings-panel" id="settingsPanel">
        <div class="toggle-row">
            <span class="toggle-label">Силуэт юзера</span>
            <label class="toggle">
                <input type="checkbox" id="toggleSilhouette" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span class="toggle-label">Webcam отражение</span>
            <label class="toggle">
                <input type="checkbox" id="toggleWebcam" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span class="toggle-label">Скелет тренера</span>
            <label class="toggle">
                <input type="checkbox" id="toggleTrainerSkel" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="slider-row">
            <span class="toggle-label">Толщина силуэта</span>
            <input type="range" id="bodyThickness" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>
        <div class="slider-row">
            <span class="toggle-label">Прозрачность webcam</span>
            <input type="range" id="webcamOpacity" min="0" max="0.5" step="0.05" value="0.25">
        </div>
    </div>
    
    <!-- Smart Mirror Layout -->
    <div class="mirror">
        <!-- User webcam as transparent background "reflection" -->
        <video id="userVideo" playsinline autoplay></video>
        
        <!-- Silhouette canvas (sausage man) -->
        <canvas id="silhouetteCanvas"></canvas>
        
        <!-- Trainer video centered -->
        <div class="trainer-container">
            <video id="trainerVideo" playsinline muted loop>
                <source src="output/trainer_transparent.webm" type="video/webm">
            </video>
            <canvas id="trainerCanvas"></canvas>
        </div>
    </div>
    
    <div class="controls">
        <button class="play-btn" id="playBtn">▶</button>
        <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
        </div>
        <div class="time-display" id="timeDisplay">0:00</div>
        <div class="stat">
            <div class="stat-value" id="scoreValue">0%</div>
            <div class="stat-label">Точность</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="repsValue">0</div>
            <div class="stat-label">Повторы</div>
        </div>
    </div>
    
    <div class="feedback" id="feedback"></div>
    
    <div class="start-overlay" id="startOverlay">
        <div class="logo" style="font-size:42px; position:static;">pers.coach</div>
        <p class="start-text">Smart Fitness Mirror</p>
        <button class="start-btn" id="startBtn">Начать</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

    <script>
        // Elements
        const trainerVideo = document.getElementById('trainerVideo');
        const trainerCanvas = document.getElementById('trainerCanvas');
        const trainerCtx = trainerCanvas.getContext('2d');
        const userVideo = document.getElementById('userVideo');
        const silhouetteCanvas = document.getElementById('silhouetteCanvas');
        const silhouetteCtx = silhouetteCanvas.getContext('2d');
        
        // Pose data
        let trainerPoses = null;
        let userLandmarks = null;
        let similarity = 0;
        let repCount = 0;
        let wasDown = false;
        
        // Load trainer poses
        fetch('output/poses/trainer_poses.json')
            .then(r => r.json())
            .then(data => { trainerPoses = data; console.log('Loaded poses:', data.poses.length); });
        
        // ============ SETTINGS ============
        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('show');
        }
        
        document.getElementById('webcamOpacity').oninput = e => {
            userVideo.style.opacity = e.target.value;
        };
        
        // ============ SMPL-STYLE SILHOUETTE ============
        // Anatomically correct body proportions based on SMPL model
        
        function drawSilhouette(landmarks) {
            const w = silhouetteCanvas.width;
            const h = silhouetteCanvas.height;
            const thickness = parseFloat(document.getElementById('bodyThickness').value);
            
            // Clear canvas
            silhouetteCtx.clearRect(0, 0, w, h);
            
            if (!landmarks || !document.getElementById('toggleSilhouette').checked) return;
            
            // Helper to get point
            const pt = (i) => landmarks[i] && landmarks[i].visibility > 0.5 ? 
                { x: landmarks[i].x * w, y: landmarks[i].y * h, v: landmarks[i].visibility } : null;
            
            // Get key landmarks
            const lShoulder = pt(11), rShoulder = pt(12);
            const lElbow = pt(13), rElbow = pt(14);
            const lWrist = pt(15), rWrist = pt(16);
            const lHip = pt(23), rHip = pt(24);
            const lKnee = pt(25), rKnee = pt(26);
            const lAnkle = pt(27), rAnkle = pt(28);
            const nose = pt(0);
            const lEar = pt(7), rEar = pt(8);
            
            if (!lShoulder || !rShoulder || !lHip || !rHip) return;
            
            // Calculate body scale based on shoulder width
            const shoulderWidth = Math.hypot(rShoulder.x - lShoulder.x, rShoulder.y - lShoulder.y);
            const baseUnit = shoulderWidth * thickness;
            
            // Silhouette style
            silhouetteCtx.fillStyle = 'rgba(255, 255, 255, 0.55)';
            silhouetteCtx.strokeStyle = 'rgba(255, 255, 255, 0.55)';
            silhouetteCtx.lineCap = 'round';
            silhouetteCtx.lineJoin = 'round';
            
            // ===== DRAW TORSO as filled shape =====
            const neck = { x: (lShoulder.x + rShoulder.x) / 2, y: (lShoulder.y + rShoulder.y) / 2 - baseUnit * 0.15 };
            const chest = { x: (lShoulder.x + rShoulder.x) / 2, y: (lShoulder.y + rShoulder.y) / 2 + baseUnit * 0.4 };
            const waist = { x: (lHip.x + rHip.x) / 2, y: (lHip.y + rHip.y) / 2 - baseUnit * 0.2 };
            const pelvis = { x: (lHip.x + rHip.x) / 2, y: (lHip.y + rHip.y) / 2 };
            
            // Torso outline (trapezoid shape: wide shoulders, narrower waist)
            silhouetteCtx.beginPath();
            silhouetteCtx.moveTo(lShoulder.x - baseUnit * 0.1, lShoulder.y);
            silhouetteCtx.lineTo(rShoulder.x + baseUnit * 0.1, rShoulder.y);
            // Right side down
            silhouetteCtx.quadraticCurveTo(
                rShoulder.x + baseUnit * 0.15, chest.y,
                waist.x + baseUnit * 0.35, waist.y
            );
            silhouetteCtx.lineTo(rHip.x + baseUnit * 0.05, rHip.y);
            silhouetteCtx.lineTo(lHip.x - baseUnit * 0.05, lHip.y);
            // Left side up
            silhouetteCtx.quadraticCurveTo(
                lShoulder.x - baseUnit * 0.15, chest.y,
                lShoulder.x - baseUnit * 0.1, lShoulder.y
            );
            silhouetteCtx.closePath();
            silhouetteCtx.fill();
            
            // ===== HEAD - anatomically sized =====
            if (nose && lEar && rEar) {
                const headWidth = Math.abs(rEar.x - lEar.x) * 0.9;
                const headHeight = headWidth * 1.2;
                const headCenterY = nose.y - headHeight * 0.35;
                
                // Oval head
                silhouetteCtx.beginPath();
                silhouetteCtx.ellipse(nose.x, headCenterY, headWidth * 0.5, headHeight * 0.5, 0, 0, Math.PI * 2);
                silhouetteCtx.fill();
                
                // Neck connection
                silhouetteCtx.beginPath();
                silhouetteCtx.moveTo(nose.x - baseUnit * 0.12, headCenterY + headHeight * 0.4);
                silhouetteCtx.lineTo(nose.x + baseUnit * 0.12, headCenterY + headHeight * 0.4);
                silhouetteCtx.lineTo(neck.x + baseUnit * 0.1, neck.y);
                silhouetteCtx.lineTo(neck.x - baseUnit * 0.1, neck.y);
                silhouetteCtx.closePath();
                silhouetteCtx.fill();
            }
            
            // ===== Helper: Draw tapered limb (SMPL-style) =====
            function drawLimb(p1, p2, startWidth, endWidth) {
                if (!p1 || !p2) return;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy);
                if (len < 1) return;
                
                // Perpendicular direction
                const px = -dy / len;
                const py = dx / len;
                
                silhouetteCtx.beginPath();
                silhouetteCtx.moveTo(p1.x + px * startWidth, p1.y + py * startWidth);
                silhouetteCtx.lineTo(p2.x + px * endWidth, p2.y + py * endWidth);
                silhouetteCtx.lineTo(p2.x - px * endWidth, p2.y - py * endWidth);
                silhouetteCtx.lineTo(p1.x - px * startWidth, p1.y - py * startWidth);
                silhouetteCtx.closePath();
                silhouetteCtx.fill();
                
                // Round joints
                silhouetteCtx.beginPath();
                silhouetteCtx.arc(p1.x, p1.y, startWidth, 0, Math.PI * 2);
                silhouetteCtx.fill();
                silhouetteCtx.beginPath();
                silhouetteCtx.arc(p2.x, p2.y, endWidth, 0, Math.PI * 2);
                silhouetteCtx.fill();
            }
            
            // ===== ARMS =====
            // Upper arms (shoulder to elbow)
            drawLimb(lShoulder, lElbow, baseUnit * 0.18, baseUnit * 0.14);
            drawLimb(rShoulder, rElbow, baseUnit * 0.18, baseUnit * 0.14);
            
            // Forearms (elbow to wrist)
            drawLimb(lElbow, lWrist, baseUnit * 0.14, baseUnit * 0.09);
            drawLimb(rElbow, rWrist, baseUnit * 0.14, baseUnit * 0.09);
            
            // ===== LEGS =====
            // Thighs (hip to knee) - muscular
            drawLimb(lHip, lKnee, baseUnit * 0.22, baseUnit * 0.16);
            drawLimb(rHip, rKnee, baseUnit * 0.22, baseUnit * 0.16);
            
            // Shins (knee to ankle)
            drawLimb(lKnee, lAnkle, baseUnit * 0.16, baseUnit * 0.10);
            drawLimb(rKnee, rAnkle, baseUnit * 0.16, baseUnit * 0.10);
            
            // ===== FEET (simple) =====
            if (lAnkle) {
                silhouetteCtx.beginPath();
                silhouetteCtx.ellipse(lAnkle.x, lAnkle.y + baseUnit * 0.08, baseUnit * 0.12, baseUnit * 0.06, 0, 0, Math.PI * 2);
                silhouetteCtx.fill();
            }
            if (rAnkle) {
                silhouetteCtx.beginPath();
                silhouetteCtx.ellipse(rAnkle.x, rAnkle.y + baseUnit * 0.08, baseUnit * 0.12, baseUnit * 0.06, 0, 0, Math.PI * 2);
                silhouetteCtx.fill();
            }
        }
        
        // ============ TRAINER SKELETON (colored by similarity) ============
        // MHR70 keypoint mappings
        const MHR70_SKELETON = [
            [5, 7, 'left_arm'],    // L shoulder -> L elbow
            [7, 62, 'left_arm'],   // L elbow -> L wrist (62 is L_wrist in MHR70)
            [6, 8, 'right_arm'],   // R shoulder -> R elbow
            [8, 41, 'right_arm'],  // R elbow -> R wrist (41 is R_wrist in MHR70)
            [5, 9, 'left_torso'],  // L shoulder -> L hip
            [6, 10, 'right_torso'],// R shoulder -> R hip
            [5, 6, 'shoulders'],   // Shoulders
            [9, 10, 'hips'],       // Hips
            [9, 11, 'left_leg'],   // L hip -> L knee
            [11, 13, 'left_leg'],  // L knee -> L ankle
            [10, 12, 'right_leg'], // R hip -> R knee
            [12, 14, 'right_leg'], // R knee -> R ankle
        ];
        
        function drawTrainerSkeleton(pose) {
            if (!document.getElementById('toggleTrainerSkel').checked) return;
            
            const kp = pose.keypoints_2d;
            if (!kp) return;
            
            const w = trainerCanvas.width;
            const h = trainerCanvas.height;
            
            MHR70_SKELETON.forEach(([i, j, group]) => {
                if (i >= kp.length || j >= kp.length) return;
                
                const p1 = kp[i], p2 = kp[j];
                if (!p1 || !p2) return;
                
                // Color based on similarity (green=good, red=bad)
                const limbSim = getLimbSimilarity(group);
                const color = getColorForScore(limbSim);
                
                trainerCtx.strokeStyle = color;
                trainerCtx.lineWidth = 4;
                trainerCtx.lineCap = 'round';
                
                trainerCtx.beginPath();
                trainerCtx.moveTo(p1[0] * w, p1[1] * h);
                trainerCtx.lineTo(p2[0] * w, p2[1] * h);
                trainerCtx.stroke();
            });
        }
        
        // Limb similarity tracking
        let limbSimilarities = {};
        
        function getLimbSimilarity(group) {
            return limbSimilarities[group] || 0;
        }
        
        function getColorForScore(score) {
            if (score > 0.8) return '#00ff88';      // Green
            if (score > 0.5) return '#ffd93d';      // Yellow
            return '#ff6b6b';                        // Red
        }
        
        // ============ POSE COMPARISON ============
        // Map MediaPipe to MHR70 equivalent indices for comparison
        const MP_TO_MHR70 = {
            11: 5,  // L shoulder
            12: 6,  // R shoulder
            13: 7,  // L elbow
            14: 8,  // R elbow
            15: 62, // L wrist
            16: 41, // R wrist
            23: 9,  // L hip
            24: 10, // R hip
            25: 11, // L knee
            26: 12, // R knee
            27: 13, // L ankle
            28: 14, // R ankle
        };
        
        function calculateSimilarity(trainerPose, userLm) {
            if (!trainerPose || !userLm) return 0;
            
            const trainerKp = trainerPose.keypoints_2d;
            if (!trainerKp) return 0;
            
            let totalSim = 0;
            let count = 0;
            
            // Reset limb similarities
            limbSimilarities = {};
            
            // Compare each limb group
            const limbGroups = {
                'left_arm': [[11, 13], [13, 15]],
                'right_arm': [[12, 14], [14, 16]],
                'left_leg': [[23, 25], [25, 27]],
                'right_leg': [[24, 26], [26, 28]],
            };
            
            for (const [group, pairs] of Object.entries(limbGroups)) {
                let groupSim = 0;
                let groupCount = 0;
                
                pairs.forEach(([mpA, mpB]) => {
                    const mhrA = MP_TO_MHR70[mpA];
                    const mhrB = MP_TO_MHR70[mpB];
                    
                    if (mhrA >= trainerKp.length || mhrB >= trainerKp.length) return;
                    
                    const tA = trainerKp[mhrA], tB = trainerKp[mhrB];
                    const uA = userLm[mpA], uB = userLm[mpB];
                    
                    if (!tA || !tB || !uA || !uB) return;
                    if (uA.visibility < 0.5 || uB.visibility < 0.5) return;
                    
                    // Compare bone angles
                    const tAngle = Math.atan2(tB[1] - tA[1], tB[0] - tA[0]);
                    const uAngle = Math.atan2(uB.y - uA.y, uB.x - uA.x);
                    
                    let angleDiff = Math.abs(tAngle - uAngle);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    const boneSim = Math.max(0, 1 - angleDiff / Math.PI);
                    groupSim += boneSim;
                    groupCount++;
                    
                    totalSim += boneSim;
                    count++;
                });
                
                limbSimilarities[group] = groupCount > 0 ? groupSim / groupCount : 0;
            }
            
            // Also set torso/shoulders/hips
            limbSimilarities['left_torso'] = (limbSimilarities['left_arm'] + limbSimilarities['left_leg']) / 2;
            limbSimilarities['right_torso'] = (limbSimilarities['right_arm'] + limbSimilarities['right_leg']) / 2;
            limbSimilarities['shoulders'] = (limbSimilarities['left_arm'] + limbSimilarities['right_arm']) / 2;
            limbSimilarities['hips'] = (limbSimilarities['left_leg'] + limbSimilarities['right_leg']) / 2;
            
            return count > 0 ? totalSim / count : 0;
        }
        
        // ============ REP COUNTING ============
        function checkRep(trainerPose) {
            if (!trainerPose || !trainerPose.keypoints_2d) return;
            
            const kp = trainerPose.keypoints_2d;
            // Check hip position relative to knees for squat detection
            const lHip = kp[9], lKnee = kp[11];
            const rHip = kp[10], rKnee = kp[12];
            
            if (!lHip || !lKnee || !rHip || !rKnee) return;
            
            const avgHipY = (lHip[1] + rHip[1]) / 2;
            const avgKneeY = (lKnee[1] + rKnee[1]) / 2;
            
            // Squat is "down" when hips are close to or below knees
            const isDown = avgHipY > avgKneeY - 0.1;
            
            if (isDown && !wasDown) {
                wasDown = true;
            } else if (!isDown && wasDown) {
                // Coming up from squat
                if (similarity > 0.5) {
                    repCount++;
                    document.getElementById('repsValue').textContent = repCount;
                    showFeedback(similarity);
                }
                wasDown = false;
            }
        }
        
        function showFeedback(score) {
            const fb = document.getElementById('feedback');
            fb.className = 'feedback';
            
            if (score > 0.8) {
                fb.textContent = 'ОТЛИЧНО!';
                fb.classList.add('great', 'show');
            } else if (score > 0.6) {
                fb.textContent = 'ХОРОШО!';
                fb.classList.add('good', 'show');
            } else {
                fb.textContent = 'СТАРАЙСЯ!';
                fb.classList.add('try', 'show');
            }
            
            setTimeout(() => fb.classList.remove('show'), 1000);
        }
        
        // ============ GET CURRENT POSE ============
        function getPose() {
            if (!trainerPoses) return null;
            
            const t = trainerVideo.currentTime;
            const fps = trainerPoses.fps || 15;
            const frameIdx = Math.floor(t * fps);
            
            return trainerPoses.poses[Math.min(frameIdx, trainerPoses.poses.length - 1)];
        }
        
        // ============ RESIZE HANDLING ============
        function resizeCanvases() {
            // Silhouette canvas = full window
            silhouetteCanvas.width = window.innerWidth;
            silhouetteCanvas.height = window.innerHeight;
            
            // Trainer canvas = match video actual pixel size
            if (trainerVideo.videoWidth > 0) {
                trainerCanvas.width = trainerVideo.videoWidth;
                trainerCanvas.height = trainerVideo.videoHeight;
            }
            console.log('Trainer canvas:', trainerCanvas.width, 'x', trainerCanvas.height);
        }
        
        window.addEventListener('resize', resizeCanvases);
        trainerVideo.addEventListener('loadedmetadata', resizeCanvases);
        trainerVideo.addEventListener('canplay', resizeCanvases);
        
        // Also resize after a short delay to ensure video dimensions are available
        setTimeout(resizeCanvases, 500);
        
        // ============ MEDIAPIPE SETUP ============
        const mpPose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });
        
        mpPose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        mpPose.onResults(results => {
            userLandmarks = results.poseLandmarks || null;
            if (userLandmarks) console.log('Got user landmarks:', userLandmarks.length);
        });
        
        // ============ START ============
        document.getElementById('startBtn').onclick = async () => {
            document.getElementById('startOverlay').classList.add('hidden');
            
            // Request webcam
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 1280, height: 720 } 
            });
            userVideo.srcObject = stream;
            
            // Apply initial opacity
            userVideo.style.opacity = document.getElementById('toggleWebcam').checked ? 
                document.getElementById('webcamOpacity').value : 0;
            
            resizeCanvases();
            
            // Start MediaPipe camera
            const cam = new Camera(userVideo, {
                onFrame: async () => { await mpPose.send({ image: userVideo }); },
                width: 1280, height: 720
            });
            cam.start();
            
            // Skip first second of video
            trainerVideo.currentTime = 1.0;
            trainerVideo.play();
            document.getElementById('playBtn').textContent = '⏸';
            
            requestAnimationFrame(loop);
        };
        
        // ============ CONTROLS ============
        document.getElementById('playBtn').onclick = () => {
            if (trainerVideo.paused) {
                trainerVideo.play();
                document.getElementById('playBtn').textContent = '⏸';
            } else {
                trainerVideo.pause();
                document.getElementById('playBtn').textContent = '▶';
            }
        };
        
        document.getElementById('timeline').onclick = e => {
            const r = e.target.getBoundingClientRect();
            trainerVideo.currentTime = ((e.clientX - r.left) / r.width) * trainerVideo.duration;
        };
        
        document.getElementById('toggleWebcam').onchange = e => {
            userVideo.style.opacity = e.target.checked ? 
                document.getElementById('webcamOpacity').value : 0;
        };
        
        // ============ MAIN LOOP ============
        function loop() {
            const trainerPose = getPose();
            
            // Clear trainer canvas
            trainerCtx.clearRect(0, 0, trainerCanvas.width, trainerCanvas.height);
            
            // Draw trainer skeleton with similarity colors
            if (trainerPose) {
                // Calculate similarity
                similarity = calculateSimilarity(trainerPose, userLandmarks);
                document.getElementById('scoreValue').textContent = Math.round(similarity * 100) + '%';
                
                // Draw colored skeleton on trainer
                drawTrainerSkeleton(trainerPose);
                
                // Check for rep completion
                checkRep(trainerPose);
            }
            
            // Draw user silhouette (sausage man)
            drawSilhouette(userLandmarks);
            
            // Update timeline
            if (trainerVideo.duration) {
                const pct = (trainerVideo.currentTime / trainerVideo.duration) * 100;
                document.getElementById('timelineProgress').style.width = pct + '%';
                const m = Math.floor(trainerVideo.currentTime / 60);
                const s = Math.floor(trainerVideo.currentTime % 60);
                document.getElementById('timeDisplay').textContent = `${m}:${s.toString().padStart(2, '0')}`;
            }
            
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
